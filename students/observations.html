<!DOCTYPE html>
<html>
<head>
    
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="generator" content="MarkBind 1.22.0">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title></title>
    <link rel="stylesheet" href="../markbind/css/bootstrap.min.css">
    <link rel="stylesheet" href="../markbind/css/bootstrap-vue.min.css">
    <link rel="stylesheet" href="../markbind/fontawesome/css/all.min.css" >
    <link rel="stylesheet" href="../markbind/glyphicons/css/bootstrap-glyphicons.min.css" >
    <link rel="stylesheet" href="../markbind/css/github.min.css">
    <link rel="stylesheet" href="../markbind/css/markbind.css">
    <link rel="stylesheet" href="../markbind/layouts/default/styles.css">
    
    
    
    <link rel="icon" href="/2019/favicon.ico">
</head>
<body>
<div id="app">
    <div id="content-wrapper">
  <div>
    <navbar placement="top" type="inverse" class="temp-navbar">
      <a slot="brand" href="/" title="Home" class="navbar-brand">CS3281&2-2019/Students</a>
      <li>
        <a href="/2019/index.html" class="nav-link">Students</a></li>
      <li>
        <a href="/2019/instructions.html" class="nav-link">Instructions</a></li>
      <li>
        <a href="/2019/students/talksSchedule.html" class="nav-link">Lightning Talks</a></li>
      <li>
        <a href="/2019/students/observations.html" class="nav-link">Observations</a></li>
      <li>
        <a href="https://nus-cs3281.github.io/website/" class="nav-link">CS3281&2 Website <span class="glyphicon glyphicon-share-alt" aria-hidden="true"></span></a></li>
      <li slot="right">
        <a href="https://github.com/nus-cs3281/2019" class="nav-link"><span class="fab fa-github"></span></a></li>
    </navbar>
    <div class="contents"></div>
  </div>
  <h1 id="observations-from-external-projects">Observations from External Projects<a class="fa fa-anchor" href="#observations-from-external-projects"></a></h1>
  <p><strong>MarkBind:</strong></p>
  <ul>
    <li><a href="#chin-kun-song-marvin">CHIN KUN SONG, MARVIN</a></li>
    <li><a href="#lin-si-jie">LIN SI JIE</a></li>
    <li><a href="#lu-yang-kenneth">LU YANG KENNETH</a></li>
    <li><a href="#maddi-aadyaa">MADDI AADYAA</a></li>
    <li><a href="#tan-zhen-yong">TAN ZHEN YONG</a></li>
  </ul>
  <p><strong>PowerPointLabs:</strong></p>
  <ul>
    <li><a href="#bryan-lew-ju-yu">BRYAN LEW JU YU</a></li>
    <li><a href="#sng-yu-feng-chester">SNG YU FENG CHESTER</a></li>
    <li><a href="#yu-pei-henry">YU PEI, HENRY</a></li>
  </ul>
  <p><strong>RepoSense:</strong></p>
  <ul>
    <li><a href="#chelsey-ong-hee">CHELSEY ONG HEE</a></li>
    <li><a href="#gilbert-emerson">GILBERT EMERSON</a></li>
    <li><a href="#ong-shu-peng">ONG SHU PENG</a></li>
    <li><a href="#wang-chao">WANG CHAO</a></li>
  </ul>
  <p><strong>TEAMMATES:</strong></p>
  <ul>
    <li><a href="#amrut-prabhu">AMRUT PRABHU</a></li>
    <li><a href="#chattoraj-ayush">CHATTORAJ AYUSH</a></li>
    <li><a href="#jeremy-choo-wun-ka">JEREMY CHOO WUN KA</a></li>
    <li><a href="#jiang-chunhui">JIANG CHUNHUI</a></li>
    <li><a href="#li-pengcheng">LI PENGCHENG</a></li>
    <li><a href="#monika-manuela-hengki">MONIKA MANUELA HENGKI</a></li>
    <li><a href="#rahul-rajesh">RAHUL RAJESH</a></li>
    <li><a href="#ronak-lakhotia">RONAK LAKHOTIA</a></li>
    <li><a href="#tan-heng-yeow">TAN HENG YEOW</a></li>
    <li><a href="#wang-junming">WANG JUNMING</a></li>
  </ul>
  <h1 id="markbind">MarkBind<a class="fa fa-anchor" href="#markbind"></a></h1>
  <box>
    <h3 id="chin-kun-song-marvin">CHIN KUN SONG, MARVIN<a class="fa fa-anchor" href="#chin-kun-song-marvin"></a></h3>
    <div>
      <h1 id="docusaurus"><a href="https://github.com/facebook/Docusaurus">Docusaurus</a><a class="fa fa-anchor" href="#docusaurus"></a></h1>
      <h1 id="project-documents">Project Documents<a class="fa fa-anchor" href="#project-documents"></a></h1>
      <h4 id="workflow">Workflow</h4>
      <ul>
        <li><a href="https://github.com/facebook/Docusaurus/blob/master/README.md">Project Readme</a></li>
        <li><a href="https://github.com/facebook/Docusaurus/blob/master/CONTRIBUTING.md">Contributing Guide</a></li>
      </ul>
      <h4 id="product-roadmap">Product Roadmap</h4>
      <ul>
        <li><a href="https://github.com/facebook/Docusaurus/issues/789">Docusaurus V2 RFC</a></li>
        <li><a href="https://docs.google.com/document/u/0/">Docusaurus V2 Design Document</a></li>
      </ul>
      <h4 id="product">Product</h4>
      <ul>
        <li><a href="https://docusaurus.io/docs/en/installation">User Documentation</a></li>
      </ul>
      <h1 id="my-contributions">My Contributions<a class="fa fa-anchor" href="#my-contributions"></a></h1>
      <ul>
        <li><a href="https://github.com/facebook/Docusaurus/pull/1186">fix: missing default value for grid block content objects #1186</a></li>
        <li><a href="https://github.com/facebook/Docusaurus/pull/1190">docs: add missing trailing slash to sample site config base url #1190</a></li>
        <li><a href="https://github.com/facebook/Docusaurus/pull/1191">fix: wrong padding for single row mobile nav #1191</a></li>
        <li><a href="https://github.com/facebook/Docusaurus/pull/1204">fix: docs asset links should follow specified docsUrl #1204</a></li>
        <li><a href="https://github.com/facebook/Docusaurus/pull/1242">Use clean url for og:url when cleanUrl is true #1242</a></li>
      </ul>
      <h1 id="what-i-learnt">What I Learnt<a class="fa fa-anchor" href="#what-i-learnt"></a></h1>
      <h4 id="workflow-2">Workflow</h4>
      <ul>
        <li>How to get onboarded to a project asynchronously, without having to communicate directly with the maintainers of the project. This was possible because:
          <ul>
            <li><strong>Clear contributing guidelines</strong> makes it easy to figure out <strong>how to contribute effectively</strong> to the project.</li>
            <li><strong>Clean project structure and code</strong> makes it easy to figure out <strong>how the product works</strong>, and by extension <strong>how to work on the codebase</strong>.</li>
          </ul>
        </li>
        <li>How to easily find issues to work on for OSS projects. This was possible because:
          <ul>
            <li><strong>Good and concise tags</strong> that describe the issue (e.g. <code>bug</code> or <code>feature request</code>) which helps contributors to quickly identify the issues that interest them.</li>
            <li>Maintainers provide an <strong>estimated difficulty level</strong>, so that contributors can determine whether the issue is likely to be workable for them based on their own familarity with the codebase.</li>
            <li>Intentionally creating/leaving a <a href="https://github.com/facebook/Docusaurus/issues/1080">trivial issue</a> for new contributors to work on helps to encourage potential new contributors to get started with the codebase without being too intimidated by harder issues.</li>
          </ul>
        </li>
        <li>Communication between users, contributors and maintainers can remain straightforward and effective even if it is completely asynchronous. This is helped by using the appropriate medium for different types of communication:
          <ul>
            <li><strong>Persistent and crowdsourced issues</strong> (e.g. feature requests, bug reports) are communicated via the <strong>GitHub issue tracker</strong>. This is an effective way for users/contributors to share information that may be useful to the rest of the community.</li>
            <li>More <strong>general, maintainer driven ideas</strong> (e.g. product roadmap and design documents) are communicated via more centralized mediums such as <strong>Google Docs, Markdown documents on GitHub, and the project blog</strong> which is more suitable for longer documents.</li>
            <li>More <strong>short-lived conversations</strong>, where information shared is more self-contained and does not need to be shared with the broader pool of users or contributors (e.g. help getting started) can be held in the <strong>Discord channel</strong>.</li>
          </ul>
        </li>
      </ul>
      <h4 id="development">Development</h4>
      <ul>
        <li>How to organize code in a way that is easily readable and extensible:
          <ul>
            <li>The Docusaurus codebase makes <strong>heavy use of abstractions</strong>. Most components, methods, and even files are relatively short. By <strong>containing only as much logic in each abstraction as necessary</strong>, the codebase becomes significantly <strong>easier to read and reason about</strong>.</li>
            <li>Good, descriptive variable names are essential for understandable code. Some useful conventions: method names should <strong>start with a verb</strong>, and variable names should be nouns that describe the <strong>content and intended use</strong> of the variable.</li>
            <li>Opt for <strong>readability over conciseness</strong>, especially for complex boolean statements (e.g. <code>!link.languages &amp;&amp; !link.search</code> is harder to understand than <code>!(link.languages || link.search)</code>).</li>
            <li>Sometimes, using mutatable variables (sparingly!) can help improve code readability, and avoid having too many variable names that need to be kept track of.</li>
          </ul>
        </li>
        <li>Using good tooling can improve developer productivity:
          <ul>
            <li>Using a <strong>good code formatter</strong> (Prettier in this case) allowed the project to retain a consistent coding style despite having multiple authors working on it. Contributors did not have to worry about how the code was formatted, which reduced a lot of friction in the review process, as well as cognitive overhead when writing the code.</li>
            <li>Using a test framework that supports <strong>component-level snapshot testing</strong> (Jest) allowed tests to be easier to write and maintain by reducing the scope of each individual test case.</li>
          </ul>
        </li>
      </ul>
      <h4 id="product-2">Product</h4>
      <ul>
        <li>A clear product vision helps to align the expectations and goals of both users and developers (though this may sound trivial, I feel that these traits are crucial to building and growing a strong community surrounding the project and allow it to grow):
          <ul>
            <li>The <strong>clearly stated aim</strong> for Docusarus to facilitate &quot;easily building, deploying, and maintaining open source project websites&quot; - which gives users and developers a <strong>clear idea of what to expect from the product</strong>. This is not only useful for the core maintainers to decide what features to work on along with their priority, but also for other contributors to feel confident in the long-term vision of the product they are working on.</li>
            <li>Similarly, <strong>offering a product roadmap</strong> gives users and contributors a <strong>sense of how the project will evolve</strong>. This can help get buy-in from users by helping them to decide if it is the right project for their use case. For developers, this can give them a better idea of what kind of work they might be doing should they decide to be a long-term contributor to the project.</li>
          </ul>
        </li>
      </ul>
      <h1 id="suggestions-for-internal-project">Suggestions for Internal Project<a class="fa fa-anchor" href="#suggestions-for-internal-project"></a></h1>
      <ul>
        <li><strong>Write (good!) contributing resources</strong>
          <ul>
            <li>As the MarkBind team changes with every CS3281/2 batch, it is essential for the project to be accessible to new contributors. It would be more productive if each new batch is able to onboard themselves to the project with minimal guidance from senior developers.</li>
            <li>Furthermore, if MarkBind is to grow as an OSS project, it would be necessary for external contributors to get involved. Without contributing documentation, external contributors may be less willing to get started working on the project.</li>
          </ul>
        </li>
        <li><strong>Improve abstractions in the codebase</strong>
          <ul>
            <li>The current codebase has several <em>massive</em> files and methods (e.g. <code>Site.js</code> and <code>Page.js</code>) and some really complex methods (e.g. <code>parser.js</code>) that are difficult to understand, and even harder to maintain or extend.</li>
            <li>Breaking these down into more layers of abstraction can help improve readability, as well as code reuse.</li>
          </ul>
        </li>
        <li><strong>Offer a more real-time form of communication</strong>
          <ul>
            <li>At the moment, all communication with external parties (both contributors and users) is done via either email or the GitHub issue tracker. While this is good for slower-paced discussions, it is not very effective for quick conversations.</li>
            <li>Having an alternate channel for such discussions (e.g. Discord, IRC, Telegram) could be useful for new users or contributors to get quick responses for the issues they face. The quicker responses via these channels might be important to drive adoption of MarkBind in an already crowded space.</li>
          </ul>
        </li>
        <li><strong>Have a clearly stated product vision and roadmap</strong>
          <ul>
            <li>Though there is a product vision that is shared internally (to be the best site for documentation websites), this vision is not shared with the public.</li>
            <li>By clearly stating the product vision, external users and contributors are able to more clearly assess if the project suits their use case, and help generate buy-in from these parties.</li>
          </ul>
        </li>
        <li><strong>Better Tooling</strong>
          <ul>
            <li>Adopting a code formatter could improve developer productivity by standardizing the formatting of the codebase. Though there are <a href="https://github.com/MarkBind/markbind/pull/758">challenges</a> in adopting a formatting tool in an existing project, I feel that finding the right tool/configurations for this is worth the initial effort and inconvenience getting used to a different formatting style as it <em>really</em> helps improve consistency and productivity - especially as the size of the team grows.</li>
            <li>Using Jest's snapshot testing to test the HTML output from individual Markdown snippets can allow user-facing features (e.g. <code>include</code>) to be easily unit tested without having to rely solely on system tests. This can be helpful in identifying regressions more effectively than <a href="https://github.com/MarkBind/markbind/issues/761#issuecomment-472759620">examining potentially large diffs</a> generated by our existing system tests.</li>
          </ul>
        </li>
        <li><strong>Use a Javascript UI library</strong>
          <ul>
            <li>At the moment, large parts of the site's HTML is generated by a combination of EJS templates, a Vue component library, and <em>plenty</em> of raw string handling.</li>
            <li>This can be rather unwieldy at times, and having several different entry points to changing the output of the site makes the rendering process unnecessarily complex and difficult to understand.</li>
            <li>We might want to consider how this can be avoided by using a single Javascript UI library (e.g. Vue or React) to handle <em>all</em> of the HTML generation. This would allow us to use one consistent layer of abstraction to deal with all HTML generation logic.</li>
            <li>This would require an overhaul of large portions of the existing logic - which might not be the best idea. Perhaps this is something that might be considered for future iterations of MarkBind.</li>
          </ul>
        </li>
      </ul>
      <h1 id="suggestions-for-external-project">Suggestions for External Project<a class="fa fa-anchor" href="#suggestions-for-external-project"></a></h1>
      <ul>
        <li><strong>Use System Tests</strong>:
          <ul>
            <li>At the moment, automated tests for the project are limited to unit tests. Most system level tests (e.g. how the entire site looks) requires manual testing.</li>
            <li>Using automated system tests to create a snapshot of a sample test site (similar to MarkBind) could help to automate this process and prevent regressions that are not detectable by the unit tests.</li>
          </ul>
        </li>
      </ul>
    </div>
  </box>
  <box>
    <h3 id="lin-si-jie">LIN SI JIE<a class="fa fa-anchor" href="#lin-si-jie"></a></h3>
    <div>
      <p><strong>Project</strong>: <a href="https://github.com/phpmyadmin/phpmyadmin">PHPMyAdmin</a></p>
      <p><strong>My contributions</strong>:</p>
      <ul>
        <li><a href="https://github.com/phpmyadmin/phpmyadmin/pull/14930">ExportJson: prevent crash when encode returns boolean #14930</a></li>
        <li><a href="https://github.com/phpmyadmin/phpmyadmin/pull/15031">Add check for empty input to change_collation #15031</a></li>
        <li><a href="https://github.com/phpmyadmin/phpmyadmin/pull/15049">Improve grammar in Validator #15049</a></li>
      </ul>
      <p><strong>Introduction</strong></p>
      <p>PHPMyAdmin is an open-sourced web interface for MySQL and MariaDB. As a portable web application written primarily in PHP, it has become one of the most popular MySQL administration tools, especially for web hosting services.
        I chose to contribute to PHPMyAdmin because it is one of the first tools I have ever used when I first learnt Web Development, and it would be meaningful for me to contribute back to the tool that has served me well for many years. Furthermore, given its large user base and nature of operations, it is important for PHPMyAdmin to engineer a reliable and secure product. This is where I had hoped to learn best reliability and security practices and apply them to my own projects.
        I am also very comfortable with the language, having used PHP primarily prior to picking up more recent languages like NodeJS.</p>
      <p><strong>Key takeaways</strong></p>
      <p>The PHPMyAdmin community has a similar process to many of the projects I've worked on, yet there are many small details that pondered reflection.</p>
      <p><strong>#1</strong> In very large projects, it is important to write code in a clean manner.
        PHPMyAdmin uses automatic tools to check for code quality and style. In addition, there is strong emphasis on writing code in classes. The nature of the underlying language, PHP, is not very OOP-focused. However, PHPMyAdmin uses many classes (e.g. forms, databases, tables etc) to abstract and simplify implementation. There is also strong evidence of reuse: constant strings, form generators, database abstractions that break down the code into much more manageable chunks.
        Even as a new developer, I had little trouble diving into PHPMyAdmin to fix bugs and add checks because it is easy to trace and understand the role of each function and each class.</p>
      <p>In contrast to my projects,
        SE-EDU: AB4's code is extremely clean and each function has its own dedicated role. With a core focus on developing as a model for teaching Software Engineering, AB4 focuses on writing our code to strictly follow OOP guidelines. However, I wonder if there is over-engineering in AB4. In PHPMyAdmin, there is a strong sense of structure - each class does its own unique role. However, things like single responsibility principle are not as strictly enforced. While these principles seem to make code cleaner, we must also remember that if the role of each function is so small, it takes more effort for a developer to trace through the code and to have a global picture of the flow in the program.</p>
      <p>MarkBind: MarkBind's code is certainly less clean than PHPMyAdmin. Even after 10 weeks of developin in MarkBind, I still have to repeatedly trace through code to understand the process. Sometimes, I need to even consult senior developers to understand how MarkBind simply &quot;magically&quot; works. This is a sign that MarkBind would need more emphasis on code maintainability. Perhaps we need to rewrite some of our functions and features as smaller, more cohesive classes.</p>
      <p><strong>#2</strong> Commit messages should be descriptive, but not overly complex.</p>
      <p>As with most Software Engineering project, high quality commit messages are a key part of Open Source Software. Commit messages allow future developers to understand why certain design decisions were made, providing a snapshot in history to make changes based on.
        PHPMyAdmin is no different - every commit needs a corresponding descriptive commit message explaining the change.</p>
      <p>However, this commit message &quot;rule&quot; is also not strictly enforced. While I try to provide convincing reasons behind the need for each commit, some developers see less point in writing a descriptive commit message. It appears that these commits are merged anyway.</p>
      <p>My experience at SE-EDU has trained me to write highly descriptive commit messages that served to convince maintainers the reason behind every commit. This is in stark contrast to commits at PHPMyAdmin or MarkBind, where developers simply need to provide a descpriton of their commit. For PHPMyAdmin, developers can even sometimes get away without writing significant commit messages.
        This has prompted me to reflect on why SE-EDU has adopted such a requirement for commit messages.
        On one hand, as a role model for Software Engineering, the project serves to teach new developers the &quot;right&quot; way. Leading by example, these messages explain commits so well that the project can be easily understood by anyone.
        On the other hand, such a system slows down development. Given that every commit needs to be tightly scoped and must accompany such an extensive commit message, the impedence to change is very high and developement cycles are slow.
        Perhaps, for an average Software Engineering project, a system similar to that of MarkBind would be ideal. While there is no fixed format and fixed requirement, developers are required to write messages that are informative and descriptive. Such an option finds a middle ground that balances ease of development and quality.</p>
      <p><strong>#3</strong> It may not be feasible to enforce good SE practices when a project grows large.</p>
      <p>The key driving component behind every Open Source Software is the quality of its commits. Like every other OSS, PhpMyAdmin uses CI tools to automate the process of code checking.
        This process is similar to my other projects: MarkBind and SE-EDU where we use CI extensively to do testing.</p>
      <p>I notice that while tests play an important role in PhpMyAdmin (some are necessary to assure functionality, others important for security), the test coverage is surprisingly low at <a href="https://codecov.io/gh/phpmyadmin/phpmyadmin">52%</a>.
        This could perhaps be due to the fact that PhpMyAdmin has so many contributors (almost 1000) and PRs on a daily basis. Having strict requirements for testing meant that it would be heavily resource intensive to ensure that new PRs are done properly with tests. In addition, this might also mean sacrificing development speed. This might further delay the release cycle and ability for the organisation to respond quickly to fixes and other updates. Being a long-time legacy project of 20 years, PhpMyAdmin started during an era where idea of testing has not yet been popular, contributing to its current poor coverage.</p>
      <p>I wonder if it's necessary to sacrifice &quot;proper&quot; software engineering practices if we want our project to expand in scale or to hasten the development process.
        For example, the high quality required by SE-EDU means that commits go through extensive revisions, small changes need to be accompanied by high overhead like commit messages, tests and documentation. The high impedence to change means that some developers could potentially avoid contributing because of the hassle.
        At the end of the day, it is the project that determines the its own priority. Then projects that focus and require reliability and quality would certainly place greater emphasis on them, mandating tests and proper coding practices. It appears in this case that this is perhaps not the focus for PHPMyAdmin.</p>
      <p>Reflecting upon MarkBind and SE-EDU, I find that both CS3282 projects are heavily tested. For MarkBind, our scale is still relatively small with significant amount of resources available to ensure reliability. On the other hand, SE-EDU/AB4 is a role model for Software Engineering. It makes sense that these projects have reliable and extensive tests, and I see little reason to change.</p>
    </div>
  </box>
  <box>
    <h3 id="lu-yang-kenneth">LU YANG KENNETH<a class="fa fa-anchor" href="#lu-yang-kenneth"></a></h3>
    <div>
      <p>Coming soon ...</p>
    </div>
  </box>
  <box>
    <h3 id="maddi-aadyaa">MADDI AADYAA<a class="fa fa-anchor" href="#maddi-aadyaa"></a></h3>
    <div>
      <h3 id="project-gatsby">Project: <a href="https://www.gatsbyjs.org/">Gatsby</a><a class="fa fa-anchor" href="#project-gatsby"></a></h3>
      <p>Gatsby is an open source framework based on React that helps developers build websites and applications faster.</p>
      <ul>
        <li><a href="https://www.gatsbyjs.org/contributing/how-to-contribute/">How to Contribute</a>: Information on contributing to issues, documentation, product website, and codebase.</li>
        <li><a href="https://www.gatsbyjs.org/contributing/rfc-process/">RFC Process</a>: Details on contributing substantial changes (using the requests for comments process).</li>
        <li><a href="https://www.gatsbyjs.org/contributing/gatsby-style-guide/">Gatsby Style Guide</a>: Guidelines for writing documentation and tutorials.</li>
      </ul>
      <h3 id="what-i-learnt-2">What I Learnt<a class="fa fa-anchor" href="#what-i-learnt-2"></a></h3>
      <ol>
        <li><strong>Define and Enforce a Workflow</strong>: Gatsby follows the standard forking workflow for bug fixes and small enhancements. More substantial changes follow the Requests for Comments process. Contributors must open a pull request that has a detailed document regarding their proposed change in a <a href="https://github.com/gatsbyjs/rfcs">separate repository</a> dedicated to RFCs. Having a separate repository provides an exclusive space for more focussed discussions on new features. I could see how this process is beneficial for a large open-source project like Gatsby as it helps them to control how new features are added to the project.</li>
        <li><strong>Have Dedicated Code Owners</strong>: Gatsby has 5 teams of <a href="https://github.com/orgs/gatsbyjs/teams/maintainers">maintainers</a> that take ownership of different areas of the project. For example, pull requests need a review from the respective code owners. Managing a huge project like Gatsby can be quite difficult for maintainers as it has the codebase, product website, documentation, and other ecosystem features like themes and plugins. Having dedicated code owners makes it more convenient for the maintainers to handle issues and review pull requests in areas they are most experienced in.</li>
        <li><strong>Automate Repetitive Tasks</strong>: As it’s a popular product, Gatsby has a lot of activity in its issue tracker. Gatsby uses a <a href="https://github.com/apps/gatsbot">bot</a> to automate some repetitive tasks, like labelling issues based on their content and closing issues after inactivity. Additionally, they use a <a href="https://github.com/marketplace/renovate">bot</a> to update the project’s dependencies. Contributors also have have to follow specific pull request and branch naming guidelines which makes it easier for automated tasks to be run on them.</li>
        <li><strong>Motivate your Contributors</strong>: For an open-source project, motivating your contributors is extremely important. Gatsby has a comprehensive guide for contributors, which includes basic information on how to triage and label issues, submit pull requests, and writing good documentation. It also has an <a href="https://www.gatsbyjs.org/docs/behind-the-scenes/">advanced guide</a> that explains how Gatsby works behind the scenes. The quality of the contributing guide is what motivated me to work on this project, as it showed me that the project was serious about helping its contributors. Gatsby encourages <a href="https://www.gatsbyjs.org/contributing/where-to-participate/">contributions</a> other than pull requests and commits. And there’s <a href="https://www.gatsbyjs.org/contributing/contributor-swag/">free swag for all contributors</a> too!</li>
        <li><strong>Interact with your Community</strong>: Gatsby has their own <a href="https://discordapp.com/invite/br9rbUE">Discord channel</a> for providing faster support to those who need it. They also host free <a href="https://www.gatsbyjs.org/contributing/pair-programming/">pair programming sessions</a> where you can work on fixing an issue with a senior developer. Interacting with your project’s open-source community is important because it provides developers with a pool of resources, which gets things done faster.</li>
      </ol>
      <h3 id="suggestions-for-markbind">Suggestions for MarkBind<a class="fa fa-anchor" href="#suggestions-for-markbind"></a></h3>
      <ol>
        <li><strong>RFC Process</strong>: Even though having a separate repository for proposing substantial code changes can be overkill, the RFC process could still be incorporated for adding new features to MarkBind.</li>
        <li><strong>Better Bug Reports</strong>: Require users to submit standalone MarkBind sites for reproducible test cases. Gatsby asks its users to create a new Gatsby site and add only those lines of code or plugins that cause a problem, publish the code, and link it in the bug report. This will be beneficial for MarkBind because the developers would not need to dig in through a lot of code to find the error, in addition to knowing the exact environment of the bug report.</li>
        <li><strong>Issue Categories</strong>: MarkBind already has issue templates, but we can take one step further and have different templates for different categories of issues like Gatsby does. For example, questions about using MarkBind and bug reports can have separate issue templates.</li>
        <li><strong>Comprehensive Contribution Guide</strong>: MarkBind will definitely benefit from a dedicated guide for new contributors on its product website.</li>
        <li><strong>Guides for Different Use Cases</strong>: Gatsby has standalone <a href="https://www.gatsbyjs.org/docs/advanced-tutorials/">advanced tutorials</a> for developing websites that have different use cases. MarkBind could have guides for developing a site that serves as a textbook, project documentation, or an eLearning resource. This will also showcase MarkBind's different features and versatility.</li>
      </ol>
    </div>
  </box>
  <box>
    <h3 id="tan-zhen-yong">TAN ZHEN YONG<a class="fa fa-anchor" href="#tan-zhen-yong"></a></h3>
    <div>
      <p>Coming soon ...</p>
    </div>
  </box>
  <h1 id="powerpointlabs">PowerPointLabs<a class="fa fa-anchor" href="#powerpointlabs"></a></h1>
  <box>
    <h3 id="bryan-lew-ju-yu">BRYAN LEW JU YU<a class="fa fa-anchor" href="#bryan-lew-ju-yu"></a></h3>
    <div>
      <h2 id="external-project-rocket-chat-ios">External Project: Rocket.Chat iOS<a class="fa fa-anchor" href="#external-project-rocket-chat-ios"></a></h2>
      <h3 id="contributions">Contributions:<a class="fa fa-anchor" href="#contributions"></a></h3>
      <ol>
        <li><a href="https://github.com/RocketChat/Rocket.Chat.iOS/pull/2494">[IMPROVEMENT] Add editing changed handler to UITextField in connect screen</a></li>
        <li><a href="https://github.com/RocketChat/Rocket.Chat.iOS/pull/2514">[NEW FEATURE] Support in-app announcements</a></li>
        <li><a href="https://github.com/RocketChat/Rocket.Chat.iOS/pull/2599">[IMPROVEMENT] Auto suggesting slash commands even when not first character</a></li>
      </ol>
      <h3 id="introduction">Introduction<a class="fa fa-anchor" href="#introduction"></a></h3>
      <p><a href="https://rocket.chat/">Rocket.Chat</a> is a free, open-sourced team communication application that allows teams and individuals to communicate and collaborate using text chats, video and audio calls, and also supports screen sharing. It is an application supported on multiple platforms, including Windows, MacOS, Linux, Android and iOS. I chose to work on the iOS application for my external project as I was intrigued by the many features this application boasts and I also hoped to be able to learn a couple of new things along the way. Over the course of the semester, I was able to contribute improvements in 2 areas, and also add a new feature to the application.</p>
      <h3 id="workflow-3">Workflow<a class="fa fa-anchor" href="#workflow-3"></a></h3>
      <p>Rocket.Chat provides a brief <a href="https://github.com/RocketChat/Rocket.Chat.iOS/blob/develop/CONTRIBUTING.md">contributor's guide</a> for people who are interested in contributing to the project. It is a largely a pretty standard workflow, where contributors simply fork and clone the project, work on the changes on a new branch, then open a pull request when ready. They have naming rules for issues, PRs and branches which help keep things organised, and some special branch names also help to automatically skip CI builds.</p>
      <h3 id="things-i-learned">Things I learned<a class="fa fa-anchor" href="#things-i-learned"></a></h3>
      <h4 id="1-documentation-is-helpful-and-important">1. Documentation is helpful and important</h4>
      <p>During the first few days of working on Rocket.Chat, I found myself lost in the thousands of lines of code, not knowing where to begin to look for the source of the bug. Usually when this is the case, we would go and look for any sort of documentation or developer guide to help us understand the code faster and to know more details, for example which classes are responsible for which features, etc. However, Rocket.Chat does not have any such documentation for its iOS application, but only has a small contirbutor's guide which does not have any details about the codebase itself.</p>
      <p>Much of my time was actually spent trying to read and understand the code, rather than to think about and write out the solution for the problem I was trying to fix. I feel that this is a rather inefficient way of working, especially in a big project like Rocket.Chat, it would be better if there was some sort of documented guide for developers so that the time spent on trying to understand the codebase is minimised.</p>
      <p>The saving grace was that the codebase was actually relatively neat and readable.</p>
      <h4 id="2-in-an-open-source-project-an-active-and-helpful-community-is-important">2. In an open-source project, an active and helpful community is important.</h4>
      <p>Continuing from my first point above, while documentation was lacking, the developer community in Rocket.Chat is strong and everyone is very helpful. From the maintainers to the senior contributors and the newcomers, it seemed like everyone was friendly and eager to help each other out, and everyone's queries are all promptly answered on both the PR thread, issue threads, and also a developer channel within the application itself! (it is a chat app that has a public server for all to join).</p>
      <p>I was actually stuck on an <a href>issue</a> for quite some time, initially relunctant to ask for help (because it was a pretty trivial problem!). But once I did reach out on the PR thread, I had a couple of replies within the next day or two, and was able to open a PR within the next week.</p>
      <h4 id="3-while-it-s-good-to-be-nice-code-reviews-must-be-taken-seriously">3. While it's good to be nice, code reviews must be taken seriously.</h4>
      <p>In all my contributions to Rocket.Chat, I find that the code reviews by the maintainers were all very thorough and detailed, and they always look to test and make sure the solution is working before it can be merged. They also require that the CI tests be passing before PRs are allowed to be merged. This is how they slowly build up a very clean and readable codebase, and it makes things easier for future developers as the process learning the codebase becomes less of a chore. I found myself slowly incorporating the practice of thorough and detailed code reviews into PowerPointLabs as well, as I realised the many benefits of not only merging working code, but also good quality code.</p>
      <h3 id="comparisons-to-powerpointlabs">Comparisons to PowerPointLabs<a class="fa fa-anchor" href="#comparisons-to-powerpointlabs"></a></h3>
      <p>PowerPointLabs can benefit from better community engagement and involvement, for both users and contributors. Possible ways are perhaps a public Slack channel where users and contributors are free to join and everyone can ask for any help and whoever is able to answer can help to solve the problem. Currently, we are handling user feedback and bug reports via email, which is not as personal and due to a one-to-one correspondence with the user, it might result in repeated work for us maintainers to give the same answer to the same question from different people. Having such a public space for direct messages can also make the exchange between users feel more personal and human.</p>
      <p>In PowerPointLabs, while we do not have the best documentation, we do have some basic technical guides targeted at developers and contributors that can help with some of the technical issues that may arise during development in the project. In this instance, I think that Rocket.Chat can probably benefit from some sort of technical documentation to aid developers in writing code for the application, given the fact that is it actually a pretty large application.</p>
    </div>
  </box>
  <box>
    <h3 id="sng-yu-feng-chester">SNG YU FENG CHESTER<a class="fa fa-anchor" href="#sng-yu-feng-chester"></a></h3>
    <div>
      <h2 id="external-project-habitica">External Project: Habitica<a class="fa fa-anchor" href="#external-project-habitica"></a></h2>
      <p><a href="https://habitica.com/">Habitica</a> is a an open-source, online task management application. Instead of the usual way of task management, Habitica takes it a step further by gamifying it. It turns your life into a role-playing game where you complete real life tasks for experience and gold, which can gain you better equipments to pimp your character.</p>
      <h3 id="workflow-4">Workflow<a class="fa fa-anchor" href="#workflow-4"></a></h3>
      <p>The workflow of the project is documented <a href="https://habitica.fandom.com/wiki/Using_Your_Local_Install_to_Modify_Habitica%27s_Website_and_API">here</a>. It is vastly similar to PowerPointLabs, where contributors fork, create a new branch on their own repo, push changes to the branch and make a pull request. One difference is that there are no conventions to follow in Habitica in the naming of the branches and pull requests.</p>
      <h3 id="takeaways-from-the-external-project">Takeaways from the External Project<a class="fa fa-anchor" href="#takeaways-from-the-external-project"></a></h3>
      <p>Habitica has been a pleasure to contribute to because of various reasons.</p>
      <p>The main reason being their documentation is <strong>clear and easy to read</strong>. Habitica has its own wiki page that contains a lot of information about the application itself. Their <a href="https://habitica.fandom.com/wiki/Setting_up_Habitica_Locally">setting up guide</a> and <a href="https://habitica.fandom.com/wiki/Using_Your_Local_Install_to_Modify_Habitica%27s_Website_and_API">instructions for contributors</a> are also on the same wiki, giving a native feel to their documentation.</p>
      <p>Fun Fact: Contributors on Habitica are not called &quot;contributors&quot;, they are called <strong>Blacksmiths</strong>.</p>
      <h5 id="habitica-shows-blacksmiths-what-they-can-contribute-to-on-their-guidance-for-blacksmiths">Habitica shows Blacksmiths what they can contribute to on their <a href="https://habitica.fandom.com/wiki/Guidance_for_Blacksmiths">Guidance For Blacksmiths</a>.</h5>
      <p>On the same page, you can find that Habitica also introduces the workflow of the project. Some FAQs like where to add images, where to add translatable strings are on the same page. Also, even though MongoDB might be widely used, Habitica also has a small section to teach Blacksmiths how to modify the database so that they are able to test their changes.</p>
      <p>For someone like me who only knew MongoDB is a great database system and not know how to use it, their instructions really helped me in my contributing process.</p>
      <h5 id="blacksmiths-are-awarded-contributor-tiers">Blacksmiths are awarded Contributor Tiers</h5>
      <p>Habitica shows their appreciation for Blacksmiths by awarding Contributor Tiers once the pull request gets merged. For example, you can see in my <a href="https://github.com/HabitRPG/habitica/pull/10965">first pull request</a>, I was awarded the first contributor tier. In game, this achievement comes as a <a href="https://imgur.com/a/MmMJi3L">badge</a> viewable in your own profile. Contributing more or longer pull requests will increase the contributor tier accordingly. Here in my <a href="https://github.com/HabitRPG/habitica/pull/11078">third pull request</a>, I was award the second tier.</p>
      <p>You can see why users of Habitica will be willing to contribute to Habitica: because Habitica gamifies the contributing as well! If you are contributing artwork or a sound piece, you will be awarded a different <a href="https://habitica.fandom.com/wiki/Contributor_Titles">contributor title</a> as well.</p>
      <h5 id="help-is-always-available-for-blacksmiths">Help is always available for Blacksmiths</h5>
      <p>Habitica has a <a href="https://habitica.fandom.com/wiki/Guilds">Guild</a> set up for Aspiring Blacksmiths. Blacksmiths that have difficulty in solving the issue can post their questions on the chat where other blacksmiths or administrators will readily help and give suggestions.</p>
      <h3 id="practices-tools-that-can-be-adopted-by-powerpointlabs">Practices/Tools that can be adopted by PowerPointLabs<a class="fa fa-anchor" href="#practices-tools-that-can-be-adopted-by-powerpointlabs"></a></h3>
      <h5 id="call-recognition-for-contributors">Call/Recognition for Contributors</h5>
      <p>There are a lot of contributors for Habitica and I believe most of them are using the Habitica application themselves (since you are able to get achievements by contributing). One possible way we can more contributors for PowerPointLabs is to advertise that help is welcomed on our <a href="https://www.comp.nus.edu.sg/~pptlabs/">website</a>.</p>
      <p>In addition to that, we can have some sort of recognition for contributors. For example, having a list of names of past contributors on the github page. For example in <a href="https://github.com/nusmodifications/nusmods">NUSMods</a>, there is a list of contributors and their github profile pictures on their first page.</p>
      <h5 id="continuous-integration">Continuous Integration</h5>
      <p>Habitica has a lot of tests (runs for 18mins in asynchronously, total time 45mins). This is the <a href="https://travis-ci.org/HabitRPG/habitica/builds/484940723?utm_source=github_status&amp;utm_medium=notification">Travis build</a> on my first PR.</p>
      <p>Continuous integration will help to keep the application away from regression. Currently, there is no easy way for PowerPointLabs to implement Continuous Integration (due to need of needing PowerPoint installed).</p>
      <p>As a result, extensive testing needs to be done on pull requests by reviewers manually so that the new changes will work on PowerPoint 2010, 2013 and 2016. At the same time, this is not efficient as it requires the reviewer to manually run the functional and unit tests.</p>
      <h5 id="documentation">Documentation</h5>
      <p>In comparison to the documentation in Habitica, the documentation in PowerPointLabs seems to fall short in being organised. For example, the <a href="https://github.com/PowerPointLabs/PowerPointLabs/blob/master/.github/CONTRIBUTING.md">contributing guide</a> contains information about submitting an issue to the release strategy of the project.</p>
      <p>Althought it is very informative, perhaps we can keep the contributing guide focused and also contain relevant contributing information from the <a href="https://github.com/PowerPointLabs/PowerPointLabs/blob/master/doc/NewcomerGuide.md">newcomer guide</a>.</p>
      <p>Also, in Habitica, the documents links to each other logically. Once an interested contributor opens up the <a href="https://habitica.fandom.com/wiki/Guidance_for_Blacksmiths">Guidance for Blacksmiths</a>, they are provided links to the <a href="https://habitica.fandom.com/wiki/Guidance_for_Blacksmiths">Setting Up Guide</a> and <a href="https://habitica.fandom.com/wiki/Using_Your_Local_Install_to_Modify_Habitica%27s_Website_and_API">Contributing Guide</a>.</p>
      <p>We can also try to make PowerPointLabs guides link to each other logically also. For example, I had problems setting up the PowerPointLabs development environent on Visual Studio. However, the solution can only be found in <a href="https://github.com/PowerPointLabs/PowerPointLabs/blob/dev-release/doc/CommonTraps.md">Common Traps</a>, instead of the <a href="https://github.com/PowerPointLabs/PowerPointLabs/blob/master/doc/ProjectSetUp.md">setting up guide</a>.</p>
    </div>
  </box>
  <box>
    <h3 id="yu-pei-henry">YU PEI, HENRY<a class="fa fa-anchor" href="#yu-pei-henry"></a></h3>
    <div>
      <h1 id="external-project-git-for-visual-studio">External project: Git for Visual Studio<a class="fa fa-anchor" href="#external-project-git-for-visual-studio"></a></h1>
      <p><a href="https://github.com/github/VisualStudio">link</a></p>
      <h2 id="online-documents-of-project-s-workflow">Online documents of project's workflow<a class="fa fa-anchor" href="#online-documents-of-project-s-workflow"></a></h2>
      <ul>
        <li><a href="https://github.com/github/VisualStudio#build-requirements">Build requirements and steps</a></li>
        <li><a href="https://github.com/github/VisualStudio#troubleshooting">Common issues when setting up</a></li>
        <li><a href="https://github.com/github/VisualStudio/blob/master/CONTRIBUTING.md">Contributing guide</a></li>
        <li><a href="https://github.com/github/VisualStudio/blob/master/CODE_OF_CONDUCT.md">Contributor Covenant Code of Conduct</a></li>
        <li><a href="http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html">Writing a good commit message</a></li>
        <li><a href="https://github.com/github/VisualStudio/blob/master/CONTRIBUTING.md#submitting-an-issue">Submitting an issue</a></li>
        <li><a href="https://github.com/github/VisualStudio/tree/master/docs">Documentation</a></li>
      </ul>
      <h2 id="things-learnt-from-project">Things learnt from project<a class="fa fa-anchor" href="#things-learnt-from-project"></a></h2>
      <ul>
        <li>Error dialogs in the application are extremely helpful in assisting new contributors in finding code related to bugs,
          in a project of such a scale (estimate over 30k LoC, with many modules).</li>
        <li>Finding more <code>good first issues</code> might be a good way to encourage new contributors to help out.
          Currently there is only 1 <code>good first issue</code> and is stale as someone asked to do the issue, but his rather old PR did not get closed after a rather long period.
          <a href="https://github.com/github/VisualStudio/pull/1989">link to PR</a>. This made me a little reluctant to start as other issues require some amount of understanding
          of a significant part of the project. It is observed that the external project does not receive new contributors often.</li>
        <li>Adding a label to an issue to describe the scope of the bug can be very helpful for new contributors. I had to rely solely on error dialogs, debuggers and some logging to find the cause of a bug.</li>
        <li>PRs that lacked description of what it fixes, how it is fixed and what tests are written are often rejected. This is important as both the contributor and the developr should
          be confident of the changes being introduced.</li>
        <li>The project uses a <code>ReadyForReview</code> label for developers.</li>
        <li>The project seems to be open to adhoc documentation fixes from public contributors. <a href="https://github.com/github/VisualStudio/pull/2231">Example</a></li>
        <li>The project uses milestone deadlines to have certain PRs merged/reviewed/completed. However, the pattern is not clear.</li>
        <li>The project merges PRs that fail CI tests by their internal memebers, probably because CI tools report false positives at times.</li>
        <li>The project uses <a href="https://github.com/github/VisualStudio/projects">projects</a> to manage issues pertaining to different aspects of project management, such as maintaining/building a feature area,
          or fixing bugs and polishing the code.</li>
        <li>The project uses <a href="https://github.com/github/VisualStudio/issues/2240">development sprints</a> to push new enhancements. The project also utilises a <a href="https://github.com/github/VisualStudio/releases">bot</a>
          to push new releases.</li>
      </ul>
      <h2 id="practices-tools-of-the-external-project-that-may-be-adoptable-by-nus-oss">Practices/tools of the external project that may be adoptable by NUS-OSS<a class="fa fa-anchor" href="#practices-tools-of-the-external-project-that-may-be-adoptable-by-nus-oss"></a></h2>
      <ul>
        <li>Use milestone deadlines for PRs/issues.</li>
        <li>Use projects to plan for longer term development.</li>
        <li>Use a bot to publish releases, and have development sprints (but the team is a little small for benefits).</li>
      </ul>
      <h2 id="optional-suggested-areas-of-improvement-for-the-external-project">[Optional] Suggested areas of improvement for the external project<a class="fa fa-anchor" href="#optional-suggested-areas-of-improvement-for-the-external-project"></a></h2>
    </div>
  </box>
  <h1 id="reposense">RepoSense<a class="fa fa-anchor" href="#reposense"></a></h1>
  <box>
    <h3 id="chelsey-ong-hee">CHELSEY ONG HEE<a class="fa fa-anchor" href="#chelsey-ong-hee"></a></h3>
    <div>
      <p>JabRef is a citation and reference management tool that helps you collect and organize your research materials.
        Here are the <a href="https://github.com/JabRef/jabref/blob/master/CONTRIBUTING.md">contributing guidelines</a>.</p>
      <p>For each pull request made, it is required to fill in a checklist. The checklist looks for 6 points - Tests are created, manual testing is done, screenshots added if UI is to change, good git commit messages are written, documentation is updated, and the change is properly logged in the file.</p>
      <p>I feel that this is a very good practice to remind developers to fulfil a certain criteria before requesting for reviews from the developers. This is especially useful for newcomers who are not familiar with the project's contributing workflow. In a way, this can also speed up the reviewing process as reviewers do not have to check for things that are already on the checklist so they can focus on ensuring good code is written instead. However, in JabRef, this checklist is commonly ignored and only certain bulletpoints are looked out for. I believe they can update this checklist to make it more relevant to both new and existing contributors. For example, the documentation status seems redundant as it is often expected of the PR author to update documentation when the code changes.</p>
      <p>The tools used by JabRef are Codacy, Travis CI and <a href="https://github.com/z0al/dep">DEP</a>. CI does a good job in ensuring that the new code passes all tests, including integration and database tests. Codacy is mainly used to check for checkstyle issues. DEP is a bot that checks for PRs which rely on other PRs/issues to be merged before they can be continued. It becomes useful when many people are working on similar areas in the project at the same time. Developers become more aware that they are working in a group and close collaboration is often needed to ensure good code quality. This may be applicable to RepoSense's frontend development.</p>
      <p>There is a Wiki page on JabRef that provides a lot of information on ways of contributing, such as <a href="https://github.com/JabRef/jabref/wiki/Code-Howtos">best code practices</a> used by JabRef specifically. As such, new code written can fit into JabRef's context easily. This is similar to the Developer Guide used in RepoSense. In future when more tools are integrated into RepoSense, notes on how tools RepoSense use can contribute to a better contribution workflow, may be written in the Developer Guide to teach new developers how to use these tools more effectively.</p>
      <p>I did encounter some difficulties trying to set up the project, because it uses JDK8 and some deprecated libraries that cannot be resolved by IntelliJ. Since new JDK libraries are mostly used in development these days, using older libraries can slow down the setting up process and delay the time used to write actual code. Furthermore, Git submodules have to be installed to use citation styles when viewing entries, but I feel that it is actually quite neat to be able to install additional libraries easily, without having to download another set of files during the development stage. Nevertheless, the <a href="https://github.com/JabRef/jabref/wiki/Guidelines-for-setting-up-a-local-workspace">guidelines</a> provided by JabRef are very easy to follow along. If one prefers learning by following instructions, a video tutorial is also available.</p>
    </div>
  </box>
  <box>
    <h3 id="gilbert-emerson">GILBERT EMERSON<a class="fa fa-anchor" href="#gilbert-emerson"></a></h3>
    <div>
      <p><strong>Electron</strong></p>
      <p><a href="https://electronjs.org/docs/development">Electron Development Documentations</a></p>
      <p>I appreciate their very structured and ordered contribution guideline, as Electron is a very big open source software. Not only that, Electron has quite cool contribution flow, going all the way from creating issue to getting your PR merged. What I observed from their process as well as how it might be applied to RepoSense are as follow:</p>
      <ul>
        <li>Structured Issue message. This is to ensure that the issue can be triaged faster and more efficient.</li>
        <li>Specific PR title formatting. This is to ensure that the PRs are nicely organized. RepoSense is still weak in this aspect as PR title is still quite haphazard.</li>
        <li>Specific branch naming, although this is already implemented by NUS-OSS, RepoSense has not really enforced this aspect</li>
        <li>Semantic commit message, although SE-EDU standard is still better. RepoSense currently employs squashed PR but this aspect may be followed.</li>
        <li>Structured PR message which although may not be on same standard with SE-EDU, it is full of semantic prefixes that is linked to bot automation. For example, you can include release note by adding <code>notes:</code>, which will be detected by Electron's release note bot and then it will process accordingly. RepoSense can follow this structure if it will use automations in the build and release process which will be listed below.</li>
        <li>Welcome Bot that welcomes new contributor. New contributor upon creating their first PR and merging it will be greeted with the bot, which will remind the user with all the contribution guidelines so the user can follow in closely if they have failed to read it beforehand. RepoSense can benefit from this when RepoSense is larger to remind new contributor what to do when they have submitted their PR.</li>
        <li>Clerk Release Note Bot that checks for <code>notes:</code> in PR message and update the release note accordingly. This is according to the idea that <code>commit -m</code> is for maintainers while <code>notes:</code> is for users. Although this bot is proprietarily developed by Electron team, RepoSense might be able to find third party alternative if RepoSense want to implement this feature in the release cycle.</li>
        <li>As Electron has multiple version release which is hosted in separate branch, a change made to latest release might need to be propagated to the previous release, essentially backporting it. This is accomplished also by automatic bot that create auto PR to previous version branch by tagging the PR with specific tag. While RepoSense currently does not have multiple version release, this idea might be beneficial for RepoSense to explore in the future.</li>
      </ul>
      <p>I also appreciate that despite being a large open source software, their most active developers are very active, responsive, and helpful in providing assistance and reviewing my code. While this is something that we may already know intuitively, perhaps from this we can be reminded again to be helpful and responsive to foster a good Open Source community.</p>
    </div>
  </box>
  <box>
    <h3 id="ong-shu-peng">ONG SHU PENG<a class="fa fa-anchor" href="#ong-shu-peng"></a></h3>
    <div>
      <p>The particular project that I picked was part of a collection of firefox extensions. As such, they use many general libraries for rendering tooltips, popups, and interacting with the browser content.</p>
      <p>These libraries are &quot;imported&quot; using the git submodule and any updates to the libraries can be easily updated through git as well. Using git submodules to manage libraries was new to me, and this was a concept that would be relevant for bigger projects with many moving parts.</p>
      <p>However, this may not be so relevent for RepoSense. Even though the frontend report interface may be thought to be a separate component from the java backend which generates the report, they are too tightly related, the frontend having strong dependency with the format of the generated reports.</p>
      <p>Another observation was the use of the <code>.editorconfig</code> file. The collection of firefox extensions is a rather large project with many different contributors. To help with the setting up of the development environment, this config file will handle code style such as indentation and trailing spaces.</p>
      <p>For projects with many different contributors this can be useful to automatically handle the different types of indentation styles. Since most editors respect the <code>.editorconfig</code> file, little has to be done to manage the file.</p>
      <p>For RepoSense, this is something we could definitely do, using a <code>.editorconfig</code> to handle different kinds of code style. This is especially important for CLI based text editors such as vim where such options cannot be conviniently changed.</p>
      <p>However, to tackle this issue, code style checkers such as eslint and checkstyle is used as part of the CI process to enforce a certain code style. The <code>.editorconfig</code> file can still come in useful for files where the style checkers miss (e.g. css files). With this configuration file, there would be less cases of early PRs having offending whitespaces changes.</p>
      <p>Another useful thing to note is that most web based ide as offered by major code repository hosting platforms like github, gitlab and bitbucket do offer support for this config file. Therefore, this will make it more convenient for developers to work on their code, using these web ides.</p>
    </div>
  </box>
  <box>
    <h3 id="wang-chao">WANG CHAO<a class="fa fa-anchor" href="#wang-chao"></a></h3>
    <div>
      <p>The external project that I picked is CheckStyle, which is a tool for checking Java source code for adherence to a Code
        Standard or set of validation rules (best practices).</p>
      <p>The link of the workflow of contributing to CheckStyle is <a href="https://checkstyle.org/contributing.html#Content">here</a></p>
      <p>The basic workflow is like this:</p>
      <ol>
        <li>Submit an issue and wait to be approved or choose an approved issue from the issue list.</li>
        <li>Work on the issue and squash the changes to one commit.</li>
        <li>Raise a PR and wait to be reviewed.</li>
        <li>Edit your PR until being approved by all maintainers.</li>
      </ol>
      <p>The workflow of CheckStyle do not have a big difference with RepoSense and SE-EDU.</p>
      <p>There are two impressive aspect when I contributes to CheckStyle. One is CI Test, another is Diff Report.</p>
      <p>For the CI Test, CheckStyle has 17 checks to pass in order to proceeded with PR. The tests covers a variety of aspects.
        For example, it ensures that the project is able to run on all JDK version and all Platforms. Also, it requires the
        code to have 100% coverage. 100% is even not enough for the tests. CheckStyle also have a test named <code>pitest</code>, which is
        a kind of mutation test. It is basically modifying the test code to look for tests failure. It will find out the lines
        that are able to be modified without tests failure, which indicates either the test case can be improved or the main code
        can be improved.</p>
      <p>For now, RepoSense do not have a coverage test yet, which may because the test coverage is not satisfying at the early
        stage of RepoSense. Now, we already have a high code coverage, so the previous concern is not true anymore. Also, having
        a coverage test allows us to improve our testing with higher revenue and lower costs. So, maybe RepoSense should integrate
        coverage test now.</p>
      <p>Currently, AB4 has coverage test. However, it do not have mutation test. As a project that teaches students about SE
        related knowledge. Maybe we can integrate mutation test in our code because it is reasonable to let the students know
        that there is another kind of test to test code quality.</p>
      <p>For Diff Report, basically, it ask all the changes related to main code that may cause a regression to generate a diff
        report, which compares the result of analysis generated for a large number of public repos before the change and after
        the change. This process is to ensure that no regression happens after the change.</p>
      <p>Because AB4 is not analysis based application, so Diff Report is not suitable for AB4.</p>
      <p>For RepoSense, we already have a Netlify preview for some Repos which plays a similar row. However, it is not same.
        Maybe we can add a tool that are able to analyze the difference of the two report generated so we can have a better
        insight of potential regressions.</p>
    </div>
  </box>
  <h1 id="teammates">TEAMMATES<a class="fa fa-anchor" href="#teammates"></a></h1>
  <box>
    <h3 id="amrut-prabhu">AMRUT PRABHU<a class="fa fa-anchor" href="#amrut-prabhu"></a></h3>
    <div>
      <h1 id="observations-from-external-project-1-open-library">~Observations from External Project 1: Open Library~<a class="fa fa-anchor" href="#observations-from-external-project-1-open-library"></a></h1>
      <ul>
        <li>Uses Docker containerisation to run the various applications. A similar procedure can be done for teammates such that running a script is enough to deploy the application.</li>
      </ul>
      <h1 id="observations-from-external-project-2-nusmods">Observations from External Project 2: NUSMods<a class="fa fa-anchor" href="#observations-from-external-project-2-nusmods"></a></h1>
      <ul>
        <li>
          <p>Code of Conduct</p>
        </li>
        <li>
          <p>Contributing Guide</p>
        </li>
        <li>
          <p>How to get in touch</p>
        </li>
        <li>
          <p>Project specific contribution guides</p>
        </li>
        <li>
          <p>Link to a blog post explaining the project and how to get started</p>
        </li>
        <li>
          <p>Netlify preview in CI</p>
        </li>
      </ul>
    </div>
  </box>
  <box>
    <h3 id="chattoraj-ayush">CHATTORAJ AYUSH<a class="fa fa-anchor" href="#chattoraj-ayush"></a></h3>
    <div>
      <p><strong>Project</strong>: FOSSASIA's <a href="http://chat.susi.ai">chat.susi.ai</a></p>
      <p><strong>My Contributions</strong>:
        Pull Requests:</p>
      <ul>
        <li>[#2052] (<a href="https://github.com/fossasia/chat.susi.ai/pull/2052">https://github.com/fossasia/chat.susi.ai/pull/2052</a>)</li>
        <li>[#2068] (<a href="https://github.com/fossasia/chat.susi.ai/pull/2068">https://github.com/fossasia/chat.susi.ai/pull/2068</a>)</li>
      </ul>
      <p>Issues:</p>
      <ul>
        <li>[#2067] (<a href="https://github.com/fossasia/chat.susi.ai/issues/2067">https://github.com/fossasia/chat.susi.ai/issues/2067</a>)</li>
        <li>[#2051] (<a href="https://github.com/fossasia/chat.susi.ai/issues/2051">https://github.com/fossasia/chat.susi.ai/issues/2051</a>)</li>
      </ul>
      <p><strong>Documentation</strong>:
        Contributor Guide: included as part of the <a href="https://github.com/fossasia/chat.susi.ai/blob/master/README.md">README</a></p>
      <p><strong>Observations</strong>:
        FOSSASIA's <a href="http://SUSI.AI">SUSI.AI</a> is an artificial intelligence system, combining pattern matching, internet data, data flow, and inference engine principles. Since <a href="http://chat.susi.ai">chat.susi.ai</a> has consistently been a Google Summer of Code project, and FOSSASIA has a reputation for being open towards first-time contributors, I thought it'll be a good experience. I also wanted to diversify and try new things - since I had had experience with VueJS, and was doing Angular in my internal project, I thought the ReactJS based <a href="http://chat.susi.ai">chat.susi.ai</a> would be the best option for me.</p>
      <h4 id="frameworks">Frameworks:</h4>
      <p>The <a href="http://chat.susi.ai">chat.susi.ai</a> is a front-end developed for web access of SUSI, and is written in ReactJS. Right out of the gate, I noted the difference in the choice of front-end frameworks between my external and internal project. Since I primarily worked on the front-end for both projects, I noted that ReactJS is significantly easier and has a much gentler curve as compared to Angular. Since TEAMMATES aims to be a student-driven project, I have fairly mixed feelings about our decision to use Angular.</p>
      <h4 id="contributing">Contributing:</h4>
      <p>While their contributor guide is very barebones compared to TEAMMATES's extensive guide, their project is actually fairly easy to set-up, and has significantly fewer rules. Their coding style is actually fairly inconsistent, unlike TEAMMATES, which has a very stringent lint. I wouldn't categorise either as good or bad, since both work just fine.</p>
      <p><a href="http://chat.susi.ai">chat.susi.ai</a> also is also less welcoming to first-timers, with no issues being flagged as first timer issues. Instead, they have a very unusual system where most contributors point out missing features themselves, and state in the issue description that they are working on the missing features (in fact, the default message for opening an issue already includes the question 'Do you want to work on it?'). I definitely prefer TEAMMATES's approach, where relevant issues that are currently the focus of the team are flagged out for first timers. They also take significantly longer to respond to PRs and queries on average.</p>
      <p>They also have multiple reviewers per Pull Request, and it is very disorienting to try to please all competing reviews on your Pull Requests. This is stark contrast to TEAMMATES, where the Project Lead strictly told us that no more than 2 contributors should review any PR, unless there is a very glaring error that has to be pointed out. This ensures that the person making the PR is not trying to juggle multiple competing suggestions at once.</p>
      <p>However, as a project with a more established front-end, they do have some very nice features that would be great for TEAMMATES.</p>
      <p>Particularly mention-worthy would be <a href="http://surge.sh">surge.sh</a>, which is a website that allows you to quickly deploy your front-end on a URL for free. All PRs made to <a href="http://chat.susi.ai">chat.susi.ai</a> require you to mention the <a href="http://surge.sh">surge.sh</a> link the project is deployed to, and the reviewers will look through the actual front-end. This, in my opinion, is better than the snapshot tests we are currently running on auto-update mode to test the rendered final product, as it is significantly easier to just look at the web page, instead of trawling through thousands of lines of HTML. I think TEAMMATES will greatly benefit by combining the use of <a href="http://surge.sh">surge.sh</a> (or similar platforms like netlify) and snapshot tests, as we can hasten the process of looking through the rendered snapshot for the 'ideal' case, and all subsequent checks can be done against an 'ideal' snapshot quickly (snapshot tests will still be needed to test all 'other' cases, but since they are less likely than the ideal scenario, it should still reduce the review workload significantly). I understand that the logistics of this will be fairly challenging, but we can explore options such as making stubs for all the API endpoints, among other things, especially given that our front-end is in such a nascent stage.</p>
      <h4 id="takeaways">Takeaways</h4>
      <p>While I certainly learned a lot about ReactJS and CSS for the purposes of making this contribution, I learned much more about how to be better reviewer, as I understood the shortcomings of a relatively poorer reviewing system. I learned that it is crucial to be enthusiastic and supportive towards contributors, as it encourages them to continue not only towards this specific project, but also Open-Source projects in general, and that we should definitely ensure that our committers have a bit more guidance when they first come onboard and start managing the project, as the reviewing process can really shape the experience of contributors.</p>
    </div>
  </box>
  <box>
    <h3 id="jeremy-choo-wun-ka">JEREMY CHOO WUN KA<a class="fa fa-anchor" href="#jeremy-choo-wun-ka"></a></h3>
    <div>
      <p>The project I am working on is called Netrunner. It is basically the digital platform to play the card game Android: Netrunner, a game set in a dystopian, sci-fi future where MNCs control the world and a group of hackers attempt to hack into those systems for their own personal reasons. <br>
        There is a slack group for developers to ask for help or discuss improvements what improvements they want to add. Invitation is gained by submitting a PR. There is also a setup guide as well as some documentation located over at <a href="https://github.com/mtgred/netrunner/wiki/Getting-Started-with-Development">/wiki page</a>. It has decent <a href="https://github.com/mtgred/netrunner/wiki/Card-definitions">documentation</a> and <a href="https://github.com/mtgred/netrunner/wiki/Getting-Started-with-Development#videos-currently-behind-a-paywall">videos</a> on how someone went through bug fixing. The <a href="https://github.com/mtgred/netrunner/wiki/Contributing-New-Cards">workflow</a> is like most other projects – post in an issue if you want to work on it, then submit a PR when you’re ready. It goes through a review process and gets merged after if it passes. <br>
        My main learning points from contributing to the project is learning how to use Clojure, a lisp-like language. Since Lisp and its variants are very different from the programming languages that I have learnt, some tasks in which I thought were easy to do has ended up taking days just to figure out what had to be done. However, through contributing to this project I’ve come to appreciate the use of Clojure in the macro level. While working on the project, it seemed like I was building the game in a language that was built to build the game, similar to how game companies build their own custom game engines for their games, this felt as if I was working on a game engine built to create Netrunner – yet that was obviously impossible, since the project was built on Clojure, not a game engine. Yet, due to the way the language used macros and virtual functions for metaprogramming, it felt like I was not working in Clojure, but a game engine built for Netrunner. <br>
        Another important thing I learnt while working on the project was the importance of communication between all the members of the development team. The slack channel set up for Netrunner is the main source of communication for all developers, and thus everything goes into the channel, be it thoughts on future development/features, further insight into code snippets or questions on how to do X. Since everything is communicated there, it acts as a big source of motivation to work on the project as well, since you read about others implementing feature X and Y or fixing some bug, which really motivates me to do the same. Furthermore, discussions on what is planned helps developers to be involved in the future direction of the project. I feel that this is hugely important to help encourage new contributors to stay and continue on with the project, otherwise they would feel like they are just being used to implement new features / fix bugs that no one else wants to do and thus was assigned to them. <br>
        Thus, I think this would be a very helpful practice that teammates can adopt. This is particularly true especially since teammates (and other NUS-OSS project) gets a yearly infusion of people to work on the project, which no other open source project has. Due to this, teammates have grown differently from other projects. Since most contributors live in Singapore, many discussions on teammates happen offline, be it requests for help or new features. Sometimes, they occur in private slack channels. Despite Teammates's OSS policy (wherein it is said they they'd prefer to discuss everything openly, using the issue tracker as a forum) there are many things that don't go on there. Since they don't happen online, others can't find them if they're encountering the same issue. Additionally, because other developers don’t get to listen in on what the senior developers are discussing, it is harder for them to see the bigger picture. Losing this main channel in which all developers are included loses a lot of the motivation that people get when working on the project. It is hard not to feel as an employee of the project when all that is done is that you are assigned tasks to complete, in which after completion you are assigned a new task. You only get to see glimpses into a small part of the project. This difference in how teammates is organized, unlike other OSS, is what I think Teammates’s biggest problem is, and why it has such trouble in retaining people to work on the project. <br></p>
    </div>
  </box>
  <box>
    <h3 id="jiang-chunhui">JIANG CHUNHUI<a class="fa fa-anchor" href="#jiang-chunhui"></a></h3>
    <div>
      <h3 id="project">Project:<a class="fa fa-anchor" href="#project"></a></h3>
      <ul>
        <li><a href="https://github.com/Kentico/cloud-sdk-swift/blob/master/CONTRIBUTING.md">Kentico Cloud Swift SDK</a></li>
      </ul>
      <h3 id="documentation-2">Documentation:<a class="fa fa-anchor" href="#documentation-2"></a></h3>
      <ul>
        <li><a href="https://github.com/Kentico/cloud-sdk-swift/blob/master/CONTRIBUTING.md">Ways to contribute</a></li>
        <li><a href="https://github.com/Kentico/cloud-sdk-swift/blob/master/CONTRIBUTING.md#submitting-pull-requests">Submit pull requests</a></li>
      </ul>
      <h3 id="contribution-so-far">Contribution so far:<a class="fa fa-anchor" href="#contribution-so-far"></a></h3>
      <ul>
        <li><a href="https://github.com/Kentico/cloud-sdk-swift/pull/63">Implement retry policy</a></li>
      </ul>
      <h3 id="observation">Observation:<a class="fa fa-anchor" href="#observation"></a></h3>
      <ul>
        <li>
          <p>As shown in the above documentation link, they also use the <a href="https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow">feature branch workflow</a>, which is similar as TEAMMATE's.</p>
        </li>
        <li>
          <p>The KenticoCloud iOS SDK developed by <a href="https://www.kentico.com/">Kentico CMS</a> is a Swift library used for retrieving web content. Since the SDK is target to developers rather than general users, the documentation is quite detailed in terms of both developer guide and inline comment. As shown in this <a href="https://github.com/Kentico/cloud-sdk-swift/blob/master/CONTRIBUTING.md#Definition-of-Done">link</a>, they require documentation in every <code>public</code> member in order to make it clear for other developers.</p>
        </li>
      </ul>
      <h3 id="what-i-have-learnt">What I have learnt<a class="fa fa-anchor" href="#what-i-have-learnt"></a></h3>
      <ul>
        <li>
          <p><strong>Write meaningful commit message and organize commit messages well.</strong> I found it important because as I used to have messy commit messages, sometimes I even confused myself when I wanted to track some files. Organizing commit message is quite a valuable skill that I learnt from contributing to open source project. TEAMMATE also emphesis organzing commit messages.</p>
        </li>
        <li>
          <p><strong>Read documentation of dependencies, and be careful to block main thread.</strong> In this <a href="https://github.com/Kentico/cloud-sdk-swift/pull/63">PR</a>, my first approach blocked the main thread, which was pointed by the maintainer. He also told me to read some documentation of dependency modules, and finally I implemented better functionality. Sometimes the dependencies have provided API that can solve the issue. I should explore them before implementating the feature from scratch.</p>
        </li>
        <li>
          <p><strong>Follow some <a href="https://tirania.org/blog/archive/2010/Dec-31.html">contribution etiquette</a>.</strong> This is written in thier contribution guide. I used to try to refactor the code for my better understanding before fixing the issue. However, I realize that applying this will cost extra effort for maintainer to review my refactoring, and is not a good practice to contribute to open source project. This link about etiquette can also be put on TEAMMATE since it will be contribute to large number of developers.</p>
        </li>
      </ul>
      <h3 id="tools">Tools<a class="fa fa-anchor" href="#tools"></a></h3>
      <ul>
        <li>Auto-generating documentation: <a href="https://github.com/realm/jazzy">jazzy</a></li>
        <li>Testing: <a href="https://github.com/Quick/Nimble">Quick/Nimble</a></li>
      </ul>
      <p>However, after exploration, these framework are typically designed for Swift/Objecive-C. Therefore, it is not applicable to NUS-OSS project currently. However, there are similar tools that support for other languages, such as <code>Javadoc</code> which can be used for TEAMMATE.</p>
      <h3 id="suggestions-to-teammate">Suggestions to TEAMMATE<a class="fa fa-anchor" href="#suggestions-to-teammate"></a></h3>
      <p>TEAMMATE can pay more attention to documentation, especially the developer guide. As an API developer, I often find it costing a lot of time to understand how does the API work, and try to consolidate it.
        Since TEAMMATE is intended to be contributed by a large number of developers, it is important to help them understand the codebase quickly. Therefore, I believe the developer guide on API layer is necessary for both backend developers to improve the API and frontend developers to use API. It will be better if the developer guide on storage lay can also be provided.</p>
    </div>
  </box>
  <box>
    <h3 id="li-pengcheng">LI PENGCHENG<a class="fa fa-anchor" href="#li-pengcheng"></a></h3>
    <div>
      <p>Coming soon ...</p>
    </div>
  </box>
  <box>
    <h3 id="monika-manuela-hengki">MONIKA MANUELA HENGKI<a class="fa fa-anchor" href="#monika-manuela-hengki"></a></h3>
    <div>
      <p><strong>Project</strong>: <a href="https://hg.mozilla.org/mozilla-central">Mozilla Firefox</a></p>
      <p><strong>My contributions</strong>:</p>
      <ul>
        <li><a href="https://phabricator.services.mozilla.com/D20943">Enable ESLint for dom/cache (automatic changes)</a></li>
        <li><a href="https://phabricator.services.mozilla.com/D20944">Enable ESLint for dom/cache (manual changes)</a></li>
        <li><a href="https://phabricator.services.mozilla.com/D22892">Drop support for PageThumbUtils.createCanvas with null window</a></li>
      </ul>
      <p><strong>Documentation</strong>:</p>
      <ul>
        <li><a href="https://developer.mozilla.org/en-US/docs/Mozilla/Developer_guide">Developer Guide</a></li>
        <li><a href="https://developer.mozilla.org/en-US/docs/Mozilla/Developer_guide/How_to_Submit_a_Patch">How to submit a patch</a></li>
      </ul>
      <p><strong>Tools</strong>:</p>
      <ul>
        <li>VCS: <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Mercurial">Mercurial</a></li>
        <li>Bugtracker: <a href="https://bugzilla.mozilla.org/home">Bugzilla</a></li>
        <li>CLI tool to submit patches: <a href="https://github.com/mozilla-conduit/review">moz-phab</a></li>
        <li>Patch review: <a href="https://phabricator.services.mozilla.com/">Phabricator</a></li>
      </ul>
      <p><strong>Observations</strong></p>
      <p>Mozilla Firefox is is a free and open-source web browser developed by The Mozilla Foundation and its subsidiary, Mozilla Corporation. I chose to contribute to Firefox because I wanted to be involved in one of the largest open source projects. Because of this scale, I can find <a href="https://codetribute.mozilla.org/">many ways where I can contribute</a> based on the language I am comfortable in (Javascript and Java).</p>
      <p><strong>Key takeaways</strong></p>
      <p>Throughout the process, I have learnt a few lessons not only as a contributor, but also as a maintainer of an open source project.</p>
      <p><strong>#1</strong> It is important to have <strong>an active community of developers who are ready to help</strong>.</p>
      <p>As a new contributor to Mozilla, the biggest obstacle I faced was getting used to the tools used in the workflow. I am used to <code>git</code> for version control (VCS), and <code>Github</code> as the bugtracker, PR tracker, and repository storage. However, Mozilla uses <code>mercurial</code> for VCS, <code>Bugzilla</code> to track bugs, <code>moz-phab</code> to submit patches, and <code>Phabricator</code> to review patches. Not only did setting up the project take some time, but the difference in tools used also created extra hurdles to me. Although the tools are quite well documented, the amount of documentations I had to read were overwhelming especially to new contributors.</p>
      <p>Even when I faced these challenges, help was readily available. There is an <a href="https://wiki.mozilla.org/IRC">IRC channel</a> dedicated to help new contributors get started. I have asked some mercurial-related questions and within 5 minutes, my questions were answered by an experienced developer from the community. Furthermore, many of the bugs were mentored. I was fortunate enough to work with a mentor who helped me as I was fixing my first bug. Even after my first patch got accepted, he willingly suggested other bugs that I can work on. The community felt very welcoming, and this definitely helped to attract and retain new contributors.</p>
      <p><strong>#2</strong> Always write <strong>clear documentation for your code</strong></p>
      <p>I observed that the documentation in the codebase is very extensive. For instance, in <a href="https://searchfox.org/mozilla-central/source/toolkit/components/thumbnails/PageThumbs.jsm#610-619">this part of the code</a>, the documentation not only mentions why certain things are being done, it also mentions related bug numbers that the person should refer to. This is helpful especially because the codebase in Mozilla is extremely huge, and it is impossible for someone to always keep track of all the code changes.</p>
      <p><strong>Suggestions for TEAMMATES</strong>:</p>
      <p>From contributing to Mozilla, here are some ways practices that TEAMMATES can adopt.</p>
      <p><strong>#1</strong> Have a <strong>communication channel for the public</strong></p>
      <p>As for now, the main communication channel used is Slack, and it is only for contributors from CS3282. It could perhaps be useful to allocate a separate Slack channel that is open to public so that new contributors can communicate directly to the maintainers. Not only would this make newcomers feel more welcome, it can also better retain new contributors so that they will keep contributing to TEAMMATES.</p>
      <p><strong>#2</strong> Having <strong>mentored bugs</strong> that new contributors can work on</p>
      <p>Currently, TEAMMATES encourage new contributors to work on <code>d.FirstTimers</code> issue so that they can familiarize themselves with the codebase and the workflow, then move on to more complicated bugs. However, some of the first timer issues such as updating the user-map may not suit new contributors who are already quite experienced and are looking for more challenging bugs. To cater to these people, perhaps TEAMMATES can have a new label for mentored bugs: bugs that are challenging but also comes with a mentor so that more experienced new contributors can work on them.</p>
      <p><strong>Suggestion for Mozilla</strong>:</p>
      <p>Perhaps Mozilla can slowly switch from using <code>mercurial</code> to using <code>git</code> as a VCS, because the number of developers and projects using <code>mercurial</code> is much smaller than those who use <code>git</code>. This will definitely be easier for new contributors to start getting involved in Mozilla.</p>
    </div>
  </box>
  <box>
    <h3 id="rahul-rajesh">RAHUL RAJESH<a class="fa fa-anchor" href="#rahul-rajesh"></a></h3>
    <div>
      <p>Coming soon ...</p>
    </div>
  </box>
  <box>
    <h3 id="ronak-lakhotia">RONAK LAKHOTIA<a class="fa fa-anchor" href="#ronak-lakhotia"></a></h3>
    <div>
      <p><strong>Project</strong>: <a href="https://github.com/exercism/java">Exercism</a></p>
      <p><strong>Contributions</strong></p>
      <ul>
        <li><a href="https://github.com/exercism/java/pull/1635">Update Error handling mechanism for existing exercise</a></li>
        <li><a href="https://github.com/exercism/java/pull/1639">Update Tests for existing exercise</a></li>
      </ul>
      <p><strong>Links to getting started with Exercism</strong></p>
      <ul>
        <li><a href="https://github.com/exercism/docs/blob/master/finding-your-way.md">Finding your way</a></li>
        <li><a href="https://github.com/exercism/docs/blob/master/contributing-to-language-tracks/README.md">Contributing to language tracks</a></li>
      </ul>
      <p><strong>Observations about the project</strong></p>
      <p>Exercism is an online platform designed to help you improve your coding skills through practice and mentorship. It provides you with thousands of exercises spread across numerous language tracks.
        I decided on contributing to Exercism because of the number of language tracks that a developer can choose from. Since I am most comfortable with Java, I made pull requests to the <a href="https://github.com/exercism/java">Java Learning Track</a>.
        One can find other languages like C++, Python, JavaScript and many more.</p>
      <p>Exercism uses tools like <a href="https://github.com/exercism/exalysis">Exalysis</a> that automatically run the tests on a solution and makes some helpful suggestions based on static analysis of the code for common errors and patterns.
        They even have a <a href="https://github.com/exercism/cli">Command Line Tool</a> for interacting with the <a href="https://exercism.io/">website</a> from the local environment.</p>
      <p>The project workflow is smooth in general. Mentors are always ready to help new developers during the initial stages. The exercism community is active and there is an online chat room too where mentors and developers can discuss their ideas.</p>
      <p><strong>Key Takeaways from this Project</strong></p>
      <p><strong>1</strong> An important thing I learned while contributing was to not be reluctant in suggesting alternative ways for a particular implementation.
        It is a good practice to discuss ideas with the mentors and eventually settle on the best path.</p>
      <p><strong>2</strong> Writing code that is readable to other developers is very important. In fact documentation in the form of comments should be minimal.</p>
      <p><strong>Improvements for Exercism</strong></p>
      <p><strong>1</strong> The documentation for Exercism could be improved. Making use of architecture diagrams or perhaps other visual aids should be included to help new developers get used to the codebase.
        <strong>2</strong> Perhaps the issues could be labelled to help newcomers. This practice is followed in TEAMMATES and can be a good addition to the Exercism project.</p>
      <p><strong>Suggestions for TEAMMATES</strong></p>
      <p>A practice that TEAMMATES could adopt from Exercism is to have a dedicated channel for new developers coming into the organization. This can really help in the onboarding process.</p>
    </div>
  </box>
  <box>
    <h3 id="tan-heng-yeow">TAN HENG YEOW<a class="fa fa-anchor" href="#tan-heng-yeow"></a></h3>
    <div>
      <p>Coming soon ...</p>
    </div>
  </box>
  <box>
    <h3 id="wang-junming">WANG JUNMING<a class="fa fa-anchor" href="#wang-junming"></a></h3>
    <div>
      <p><strong>Project</strong>
        <a href="https://github.com/exercism">Exercism</a></p>
      <p><strong>My contributions:</strong></p>
      <ul>
        <li><a href="https://github.com/exercism/python/pull/1690">#745</a></li>
        <li><a href="https://github.com/exercism/java/pull/1642">#1642</a></li>
      </ul>
      <p><strong>Observations:</strong></p>
      <p><a href="https://exercism.io/my/tracks">Exercism</a> is an online interactive tool for learning new programming languages. It supports more than 40 programming languages. Each language has its own exercise repo, which contains a set of exercises to improve your skills. Each language repo is maintained by some senior developers(all volunteers), who is in charge of maintaining, updating and reviewing new PRs.</p>
      <p>Overall, the project's documentation is well-written. They have general documentation about how to get started to contribute, which can be found <a href="https://github.com/exercism/docs/tree/master/contributing-to-language-tracks">here</a>. This is because although those repos differ from language to language, the general workflow of contributing is almost the same. It preserves the consistency across different repos. And make it much easier to contribute across different language repos. Apart from that, different repos also have their own supplementary documentation, which includes more detailed guidance and specification to help newcomers to get started. They have also created a separate repo named <a href="https://github.com/exercism/problem-specifications">problem-specifications</a>, it includes all the information about the exercises you can implement. In addition, exercism has kindly developed a tool <a href="https://github.com/exercism/configlet">configlet</a>, which is an integrated tool that could generate templates, lint, upgrading etc. It automates all the tedious works and let developers focus more on the development. However, unlike TEAMMATES, they never use any graphics in their documentation, I think include some proper diagrams will make newcomers to understand the project structure more easily. Lastly, when I worked across different language repos, I found their labels for issues are inconsistent across different repos. Each repo has its own set of labels for issues, and some times similar labels can mean different things in different repos.</p>
      <p>The contribution workflow is similar to TEAMMATES as can be found <a href="https://github.com/exercism/docs/blob/master/you-can-help/implement-an-exercise-from-specification.md">here</a>. One thing I liked about exercism is that they have strict regulations about commit messages, they have even kindly included some article of <a href="https://chris.beams.io/posts/git-commit/#seven-rules">how to write good commit messages</a>, I really enjoyed those articles and learned a lot from it. Recall when I was working on my <a href="https://github.com/TEAMMATES/teammates/pull/9436">first task</a> of TEAMMATES on API consolidation, the commit messages are just a mess. However, I gradually learned how to organize the message after reading those articles. Organizing commit messages not only make the reviewer's life easier, but also shorten the review process since everything becomes clearer.</p>
      <p>One thing I observed is that many large-scale open source projects(not only exercism) tend to make their project easy to get started for newcomers. Either by writing high-quality documentation, provide a tool for automating tedious work or label some first-timer issue. All those encourages for contributing. Although TEAMMATES has well-written documentation and labeled first-timers issue properly, I notice it does not have many volunteered contributors. One key reason might be its relatively complicated local set up instruction(although is well written). Nowadays many projects are migrating to <a href="https://www.docker.com/">Docker</a>, which makes local set up as easy as one command. Should TEAMMATES apply docker also?</p>
    </div>
  </box>
</div>
<div id="flex-div"></div>
<footer>
  <div class="text-center">
    <p><small>This page was built with <img src="https://markbind.org/favicon.ico" width="20"> <a href="https://markbind.org/">MarkBind 1.22.0</a> at Tue, 26 Mar 2019 15:15:14 GMT</small></p>
  </div>
</footer>
</div>
</body>
<script src="../markbind/js/vue.min.js"></script>
<script src="../markbind/js/vue-strap.min.js"></script>
<script src="../markbind/js/bootstrap-utility.min.js"></script>
<script src="../markbind/js/polyfill.min.js"></script>
<script src="../markbind/js/bootstrap-vue.min.js"></script>
<script>
    const baseUrl = '/2019'
    const enableSearch = true
</script>
<script src="../markbind/js/setup.js"></script>
<script src="../markbind/layouts/default/scripts.js"></script>
</html>
